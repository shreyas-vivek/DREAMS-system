{"ast":null,"code":"var pull = require('pull-stream/pull');\n\nvar looper = require('looper');\n\nfunction destroy(stream) {\n  if (!stream.destroy) console.error('warning, stream-to-pull-stream: \\n' + 'the wrapped node-stream does not implement `destroy`, \\n' + 'this may cause resource leaks.');else stream.destroy();\n}\n\nfunction write(read, stream, cb) {\n  var ended,\n      closed = false,\n      did;\n\n  function done() {\n    if (did) return;\n    did = true;\n    cb && cb(ended === true ? null : ended);\n  }\n\n  function onClose() {\n    if (closed) return;\n    closed = true;\n    cleanup();\n    if (!ended) read(ended = true, done);else done();\n  }\n\n  function onError(err) {\n    cleanup();\n    if (!ended) read(ended = err, done);\n  }\n\n  function cleanup() {\n    stream.on('finish', onClose);\n    stream.removeListener('close', onClose);\n    stream.removeListener('error', onError);\n  }\n\n  stream.on('close', onClose);\n  stream.on('finish', onClose);\n  stream.on('error', onError);\n  process.nextTick(function () {\n    looper(function (next) {\n      read(null, function (end, data) {\n        ended = ended || end; //you can't \"end\" a stdout stream, so this needs to be handled specially.\n\n        if (end === true) return stream._isStdio ? done() : stream.end();\n\n        if (ended = ended || end) {\n          destroy(stream);\n          return done(ended);\n        } //I noticed a problem streaming to the terminal:\n        //sometimes the end got cut off, creating invalid output.\n        //it seems that stdout always emits \"drain\" when it ends.\n        //so this seems to work, but i have been unable to reproduce this test\n        //automatically, so you need to run ./test/stdout.js a few times and the end is valid json.\n\n\n        if (stream._isStdio) stream.write(data, function () {\n          next();\n        });else {\n          var pause = stream.write(data);\n          if (pause === false) stream.once('drain', next);else next();\n        }\n      });\n    });\n  });\n}\n\nfunction first(emitter, events, handler) {\n  function listener(val) {\n    events.forEach(function (e) {\n      emitter.removeListener(e, listener);\n    });\n    handler(val);\n  }\n\n  events.forEach(function (e) {\n    emitter.on(e, listener);\n  });\n  return emitter;\n}\n\nfunction read2(stream) {\n  var ended = false,\n      waiting = false;\n\n  var _cb;\n\n  function read() {\n    var data = stream.read();\n\n    if (data !== null && _cb) {\n      var cb = _cb;\n      _cb = null;\n      cb(null, data);\n    }\n  }\n\n  stream.on('readable', function () {\n    waiting = true;\n    _cb && read();\n  }).on('end', function () {\n    ended = true;\n    _cb && _cb(ended);\n  }).on('error', function (err) {\n    ended = err;\n    _cb && _cb(ended);\n  });\n  return function (end, cb) {\n    _cb = cb;\n    if (ended) cb(ended);else if (waiting) read();\n  };\n}\n\nfunction read1(stream) {\n  var buffer = [],\n      cbs = [],\n      ended,\n      paused = false;\n  var draining;\n\n  function drain() {\n    while ((buffer.length || ended) && cbs.length) cbs.shift()(buffer.length ? null : ended, buffer.shift());\n\n    if (!buffer.length && paused) {\n      paused = false;\n      stream.resume();\n    }\n  }\n\n  stream.on('data', function (data) {\n    buffer.push(data);\n    drain();\n\n    if (buffer.length && stream.pause) {\n      paused = true;\n      stream.pause();\n    }\n  });\n  stream.on('end', function () {\n    ended = true;\n    drain();\n  });\n  stream.on('close', function () {\n    ended = true;\n    drain();\n  });\n  stream.on('error', function (err) {\n    ended = err;\n    drain();\n  });\n  return function (abort, cb) {\n    if (!cb) throw new Error('*must* provide cb');\n\n    if (abort) {\n      function onAbort() {\n        while (cbs.length) cbs.shift()(abort);\n\n        cb(abort);\n      } //if the stream happens to have already ended, then we don't need to abort.\n\n\n      if (ended) return onAbort();\n      stream.once('close', onAbort);\n      destroy(stream);\n    } else {\n      cbs.push(cb);\n      drain();\n    }\n  };\n}\n\nvar read = read1;\n\nvar sink = function (stream, cb) {\n  return function (read) {\n    return write(read, stream, cb);\n  };\n};\n\nvar source = function (stream) {\n  return read1(stream);\n};\n\nexports = module.exports = function (stream, cb) {\n  return stream.writable && stream.write ? stream.readable ? function (_read) {\n    write(_read, stream, cb);\n    return read1(stream);\n  } : sink(stream, cb) : source(stream);\n};\n\nexports.sink = sink;\nexports.source = source;\nexports.read = read;\nexports.read1 = read1;\nexports.read2 = read2;\n\nexports.duplex = function (stream, cb) {\n  return {\n    source: source(stream),\n    sink: sink(stream, cb)\n  };\n};\n\nexports.transform = function (stream) {\n  return function (read) {\n    var _source = source(stream);\n\n    sink(stream)(read);\n    return _source;\n  };\n};","map":{"version":3,"names":["pull","require","looper","destroy","stream","console","error","write","read","cb","ended","closed","did","done","onClose","cleanup","onError","err","on","removeListener","process","nextTick","next","end","data","_isStdio","pause","once","first","emitter","events","handler","listener","val","forEach","e","read2","waiting","_cb","read1","buffer","cbs","paused","draining","drain","length","shift","resume","push","abort","Error","onAbort","sink","source","exports","module","writable","readable","_read","duplex","transform","_source"],"sources":["C:/Users/Shreyas/Desktop/DMR-master/client/node_modules/stream-to-pull-stream/index.js"],"sourcesContent":["var pull = require('pull-stream/pull')\nvar looper = require('looper')\n\nfunction destroy (stream) {\n  if(!stream.destroy)\n    console.error(\n      'warning, stream-to-pull-stream: \\n'\n    + 'the wrapped node-stream does not implement `destroy`, \\n'\n    + 'this may cause resource leaks.'\n    )\n  else stream.destroy()\n\n}\n\nfunction write(read, stream, cb) {\n  var ended, closed = false, did\n  function done () {\n    if(did) return\n    did = true\n    cb && cb(ended === true ? null : ended)\n  }\n\n  function onClose () {\n    if(closed) return\n    closed = true\n    cleanup()\n    if(!ended) read(ended = true, done)\n    else       done()\n  }\n  function onError (err) {\n    cleanup()\n    if(!ended) read(ended = err, done)\n  }\n  function cleanup() {\n    stream.on('finish', onClose)\n    stream.removeListener('close', onClose)\n    stream.removeListener('error', onError)\n  }\n  stream.on('close', onClose)\n  stream.on('finish', onClose)\n  stream.on('error', onError)\n  process.nextTick(function () {\n    looper(function (next) {\n      read(null, function (end, data) {\n        ended = ended || end\n        //you can't \"end\" a stdout stream, so this needs to be handled specially.\n        if(end === true)\n          return stream._isStdio ? done() : stream.end()\n\n        if(ended = ended || end) {\n          destroy(stream)\n          return done(ended)\n        }\n\n        //I noticed a problem streaming to the terminal:\n        //sometimes the end got cut off, creating invalid output.\n        //it seems that stdout always emits \"drain\" when it ends.\n        //so this seems to work, but i have been unable to reproduce this test\n        //automatically, so you need to run ./test/stdout.js a few times and the end is valid json.\n        if(stream._isStdio)\n          stream.write(data, function () { next() })\n        else {\n          var pause = stream.write(data)\n          if(pause === false)\n            stream.once('drain', next)\n          else next()\n        }\n      })\n    })\n  })\n}\n\nfunction first (emitter, events, handler) {\n  function listener (val) {\n    events.forEach(function (e) {\n      emitter.removeListener(e, listener)\n    })\n    handler(val)\n  }\n  events.forEach(function (e) {\n    emitter.on(e, listener)\n  })\n  return emitter\n}\n\nfunction read2(stream) {\n  var ended = false, waiting = false\n  var _cb\n\n  function read () {\n    var data = stream.read()\n    if(data !== null && _cb) {\n      var cb = _cb; _cb = null\n      cb(null, data)\n    }\n  }\n\n  stream.on('readable', function () {\n    waiting = true\n    _cb && read()\n  })\n  .on('end', function () {\n    ended = true\n    _cb && _cb(ended)\n  })\n  .on('error', function (err) {\n    ended = err\n    _cb && _cb(ended)\n  })\n\n  return function (end, cb) {\n    _cb = cb\n    if(ended)\n      cb(ended)\n    else if(waiting)\n      read()\n  }\n}\n\nfunction read1(stream) {\n  var buffer = [], cbs = [], ended, paused = false\n\n  var draining\n  function drain() {\n    while((buffer.length || ended) && cbs.length)\n      cbs.shift()(buffer.length ? null : ended, buffer.shift())\n    if(!buffer.length && (paused)) {\n      paused = false\n      stream.resume()\n    }\n  }\n\n  stream.on('data', function (data) {\n    buffer.push(data)\n    drain()\n    if(buffer.length && stream.pause) {\n      paused = true\n      stream.pause()\n    }\n  })\n  stream.on('end', function () {\n    ended = true\n    drain()\n  })\n  stream.on('close', function () {\n    ended = true\n    drain()\n  })\n  stream.on('error', function (err) {\n    ended = err\n    drain()\n  })\n  return function (abort, cb) {\n    if(!cb) throw new Error('*must* provide cb')\n    if(abort) {\n      function onAbort () {\n        while(cbs.length) cbs.shift()(abort)\n        cb(abort)\n      }\n      //if the stream happens to have already ended, then we don't need to abort.\n      if(ended) return onAbort()\n      stream.once('close', onAbort)\n      destroy(stream)\n    }\n    else {\n      cbs.push(cb)\n      drain()\n    }\n  }\n}\n\nvar read = read1\n\nvar sink = function (stream, cb) {\n  return function (read) {\n    return write(read, stream, cb)\n  }\n}\n\nvar source = function (stream) {\n  return read1(stream)\n}\n\nexports = module.exports = function (stream, cb) {\n  return (\n    (stream.writable && stream.write)\n    ? stream.readable\n      ? function(_read) {\n          write(_read, stream, cb);\n          return read1(stream)\n        }\n      : sink(stream, cb)\n    : source(stream)\n  )\n}\n\nexports.sink = sink\nexports.source = source\nexports.read = read\nexports.read1 = read1\nexports.read2 = read2\nexports.duplex = function (stream, cb) {\n  return {\n    source: source(stream),\n    sink: sink(stream, cb)\n  }\n}\nexports.transform = function (stream) {\n  return function (read) {\n    var _source = source(stream)\n    sink(stream)(read); return _source\n  }\n}\n\n\n\n\n\n\n\n\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}