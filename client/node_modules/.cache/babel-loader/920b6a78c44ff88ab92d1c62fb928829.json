{"ast":null,"code":"'use strict';\n\nconst {\n  Duplex\n} = require('readable-stream');\n\nconst eachSeries = require('async/eachSeries');\n\nconst isStream = require('is-stream');\n\nconst once = require('once');\n\nconst prepareFile = require('./prepare-file');\n\nconst Multipart = require('./multipart');\n\nfunction headers(file, i) {\n  const filename = file.path ? encodeURIComponent(file.path) : '';\n  const header = {\n    'Content-Disposition': `form-data; name=\"data${i}\"; filename=\"${filename}\"`\n  };\n\n  if (!file.content) {\n    header['Content-Type'] = 'application/x-directory';\n  } else if (file.symlink) {\n    header['Content-Type'] = 'application/symlink';\n  } else {\n    header['Content-Type'] = 'application/octet-stream';\n  }\n\n  return header;\n}\n\nmodule.exports = (send, path) => {\n  return options => {\n    let request;\n    let ended = false;\n    let writing = false;\n    options = options ? Object.assign({}, options, options.qs) : {};\n    const multipart = new Multipart();\n    const retStream = new Duplex({\n      objectMode: true\n    });\n\n    retStream._read = n => {};\n\n    retStream._write = (file, enc, _next) => {\n      const next = once(_next);\n\n      try {\n        const files = prepareFile(file, options).map((file, i) => Object.assign({\n          headers: headers(file, i)\n        }, file));\n        writing = true;\n        eachSeries(files, (file, cb) => multipart.write(file, enc, cb), err => {\n          writing = false;\n\n          if (err) {\n            return next(err);\n          }\n\n          if (ended) {\n            multipart.end();\n          }\n\n          next();\n        });\n      } catch (err) {\n        next(err);\n      }\n    };\n\n    retStream.once('finish', () => {\n      if (!ended) {\n        ended = true;\n\n        if (!writing) {\n          multipart.end();\n        }\n      }\n    });\n    const qs = options.qs || {};\n    qs['cid-version'] = propOrProp(options, 'cid-version', 'cidVersion');\n    qs['raw-leaves'] = propOrProp(options, 'raw-leaves', 'rawLeaves');\n    qs['only-hash'] = propOrProp(options, 'only-hash', 'onlyHash');\n    qs['wrap-with-directory'] = propOrProp(options, 'wrap-with-directory', 'wrapWithDirectory');\n    qs.hash = propOrProp(options, 'hash', 'hashAlg');\n\n    if (options.strategy === 'trickle' || options.trickle) {\n      qs['trickle'] = 'true';\n    }\n\n    const args = {\n      path: path,\n      qs: qs,\n      args: options.args,\n      multipart: true,\n      multipartBoundary: multipart._boundary,\n      stream: true,\n      recursive: true,\n      progress: options.progress\n    };\n    multipart.on('error', err => {\n      retStream.emit('error', err);\n    });\n    request = send(args, (err, response) => {\n      if (err) {\n        return retStream.emit('error', err);\n      }\n\n      if (!response) {\n        // no response, which means everything is ok, so we end the retStream\n        return retStream.push(null); // early\n      }\n\n      if (!isStream(response)) {\n        retStream.push(response);\n        retStream.push(null);\n        return;\n      }\n\n      response.on('error', err => retStream.emit('error', err));\n\n      if (options.converter) {\n        response.on('data', d => {\n          if (d.Bytes && options.progress) {\n            options.progress(d.Bytes);\n          }\n        });\n        const Converter = options.converter;\n        const convertedResponse = new Converter();\n        convertedResponse.once('end', () => retStream.push(null));\n        convertedResponse.on('data', d => retStream.push(d));\n        response.pipe(convertedResponse);\n      } else {\n        response.on('data', d => {\n          if (d.Bytes && options.progress) {\n            options.progress(d.Bytes);\n          }\n\n          retStream.push(d);\n        });\n        response.once('end', () => retStream.push(null));\n      }\n    }); // signal the multipart that the underlying stream has drained and that\n    // it can continue producing data..\n\n    request.on('drain', () => multipart.emit('drain'));\n    multipart.pipe(request);\n    return retStream;\n  };\n};\n\nfunction propOrProp(source, prop1, prop2) {\n  if (prop1 in source) {\n    return source[prop1];\n  } else if (prop2 in source) {\n    return source[prop2];\n  }\n}","map":{"version":3,"names":["Duplex","require","eachSeries","isStream","once","prepareFile","Multipart","headers","file","i","filename","path","encodeURIComponent","header","content","symlink","module","exports","send","options","request","ended","writing","Object","assign","qs","multipart","retStream","objectMode","_read","n","_write","enc","_next","next","files","map","cb","write","err","end","propOrProp","hash","strategy","trickle","args","multipartBoundary","_boundary","stream","recursive","progress","on","emit","response","push","converter","d","Bytes","Converter","convertedResponse","pipe","source","prop1","prop2"],"sources":["C:/Users/Shreyas/Desktop/DREAMS/DMR-master/DREAMS-system/client/node_modules/ipfs-http-client/src/utils/send-files-stream.js"],"sourcesContent":["'use strict'\n\nconst { Duplex } = require('readable-stream')\nconst eachSeries = require('async/eachSeries')\nconst isStream = require('is-stream')\nconst once = require('once')\nconst prepareFile = require('./prepare-file')\nconst Multipart = require('./multipart')\n\nfunction headers (file, i) {\n  const filename = file.path\n    ? encodeURIComponent(file.path)\n    : ''\n\n  const header = { 'Content-Disposition': `form-data; name=\"data${i}\"; filename=\"${filename}\"` }\n\n  if (!file.content) {\n    header['Content-Type'] = 'application/x-directory'\n  } else if (file.symlink) {\n    header['Content-Type'] = 'application/symlink'\n  } else {\n    header['Content-Type'] = 'application/octet-stream'\n  }\n\n  return header\n}\n\nmodule.exports = (send, path) => {\n  return (options) => {\n    let request\n    let ended = false\n    let writing = false\n\n    options = options ? Object.assign({}, options, options.qs) : {}\n\n    const multipart = new Multipart()\n\n    const retStream = new Duplex({ objectMode: true })\n\n    retStream._read = (n) => {}\n\n    retStream._write = (file, enc, _next) => {\n      const next = once(_next)\n      try {\n        const files = prepareFile(file, options)\n          .map((file, i) => Object.assign({ headers: headers(file, i) }, file))\n\n        writing = true\n        eachSeries(\n          files,\n          (file, cb) => multipart.write(file, enc, cb),\n          (err) => {\n            writing = false\n            if (err) {\n              return next(err)\n            }\n            if (ended) {\n              multipart.end()\n            }\n            next()\n          })\n      } catch (err) {\n        next(err)\n      }\n    }\n\n    retStream.once('finish', () => {\n      if (!ended) {\n        ended = true\n        if (!writing) {\n          multipart.end()\n        }\n      }\n    })\n\n    const qs = options.qs || {}\n\n    qs['cid-version'] = propOrProp(options, 'cid-version', 'cidVersion')\n    qs['raw-leaves'] = propOrProp(options, 'raw-leaves', 'rawLeaves')\n    qs['only-hash'] = propOrProp(options, 'only-hash', 'onlyHash')\n    qs['wrap-with-directory'] = propOrProp(options, 'wrap-with-directory', 'wrapWithDirectory')\n    qs.hash = propOrProp(options, 'hash', 'hashAlg')\n\n    if (options.strategy === 'trickle' || options.trickle) {\n      qs['trickle'] = 'true'\n    }\n\n    const args = {\n      path: path,\n      qs: qs,\n      args: options.args,\n      multipart: true,\n      multipartBoundary: multipart._boundary,\n      stream: true,\n      recursive: true,\n      progress: options.progress\n    }\n\n    multipart.on('error', (err) => {\n      retStream.emit('error', err)\n    })\n\n    request = send(args, (err, response) => {\n      if (err) {\n        return retStream.emit('error', err)\n      }\n\n      if (!response) {\n        // no response, which means everything is ok, so we end the retStream\n        return retStream.push(null) // early\n      }\n\n      if (!isStream(response)) {\n        retStream.push(response)\n        retStream.push(null)\n        return\n      }\n\n      response.on('error', (err) => retStream.emit('error', err))\n\n      if (options.converter) {\n        response.on('data', (d) => {\n          if (d.Bytes && options.progress) {\n            options.progress(d.Bytes)\n          }\n        })\n\n        const Converter = options.converter\n        const convertedResponse = new Converter()\n        convertedResponse.once('end', () => retStream.push(null))\n        convertedResponse.on('data', (d) => retStream.push(d))\n        response.pipe(convertedResponse)\n      } else {\n        response.on('data', (d) => {\n          if (d.Bytes && options.progress) {\n            options.progress(d.Bytes)\n          }\n          retStream.push(d)\n        })\n        response.once('end', () => retStream.push(null))\n      }\n    })\n\n    // signal the multipart that the underlying stream has drained and that\n    // it can continue producing data..\n    request.on('drain', () => multipart.emit('drain'))\n\n    multipart.pipe(request)\n\n    return retStream\n  }\n}\n\nfunction propOrProp (source, prop1, prop2) {\n  if (prop1 in source) {\n    return source[prop1]\n  } else if (prop2 in source) {\n    return source[prop2]\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}