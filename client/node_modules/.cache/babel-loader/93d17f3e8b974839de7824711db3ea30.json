{"ast":null,"code":"'use strict';\n\nconst Transform = require('readable-stream').Transform;\n\nconst isNode = require('detect-node');\n\nconst PADDING = '--';\nconst NEW_LINE = '\\r\\n';\nconst NEW_LINE_BUFFER = Buffer.from(NEW_LINE);\n\nclass Multipart extends Transform {\n  constructor(options) {\n    super(Object.assign({}, options, {\n      objectMode: true,\n      highWaterMark: 1\n    }));\n    this._boundary = this._generateBoundary();\n    this._files = [];\n    this._draining = false;\n  }\n\n  _flush() {\n    this.push(Buffer.from(PADDING + this._boundary + PADDING + NEW_LINE));\n    this.push(null);\n  }\n\n  _generateBoundary() {\n    var boundary = '--------------------------';\n\n    for (var i = 0; i < 24; i++) {\n      boundary += Math.floor(Math.random() * 10).toString(16);\n    }\n\n    return boundary;\n  }\n\n  _transform(file, encoding, callback) {\n    if (Buffer.isBuffer(file)) {\n      this.push(file);\n      return callback(); // early\n    } // not a buffer, must be a file\n\n\n    this._files.push(file);\n\n    this._maybeDrain(callback);\n  }\n\n  _maybeDrain(callback) {\n    if (!this._draining) {\n      if (this._files.length) {\n        this._draining = true;\n\n        const file = this._files.shift();\n\n        this._pushFile(file, err => {\n          this._draining = false;\n\n          if (err) {\n            this.emit('error', err);\n          } else {\n            this._maybeDrain(callback);\n          }\n        });\n      } else {\n        this.emit('drained all files');\n        callback();\n      }\n    } else {\n      this.once('drained all files', callback);\n    }\n  }\n\n  _pushFile(file, callback) {\n    const leading = this._leading(file.headers || {});\n\n    this.push(leading);\n    let content = file.content || Buffer.alloc(0);\n\n    if (Buffer.isBuffer(content)) {\n      this.push(content);\n      this.push(NEW_LINE_BUFFER);\n      return callback(); // early\n    } // From now on we assume content is a stream\n\n\n    content.once('error', this.emit.bind(this, 'error'));\n    content.once('end', () => {\n      this.push(NEW_LINE_BUFFER);\n      callback(); // TODO: backpressure!!! wait once self is drained so we can proceed\n      // This does not work\n      // this.once('drain', () => {\n      //   callback()\n      // })\n    });\n    content.on('data', data => {\n      const drained = this.push(data); // Only do the drain dance on Node.js.\n      // In browserland, the underlying stream\n      // does NOT drain because the request is only sent\n      // once this stream ends.\n\n      if (!drained && isNode) {\n        content.pause();\n        this.once('drain', () => content.resume());\n      }\n    });\n  }\n\n  _leading(headers) {\n    var leading = [PADDING + this._boundary];\n    Object.keys(headers).forEach(header => {\n      leading.push(header + ': ' + headers[header]);\n    });\n    leading.push('');\n    leading.push('');\n    const leadingStr = leading.join(NEW_LINE);\n    return Buffer.from(leadingStr);\n  }\n\n}\n\nmodule.exports = Multipart;","map":{"version":3,"names":["Transform","require","isNode","PADDING","NEW_LINE","NEW_LINE_BUFFER","Buffer","from","Multipart","constructor","options","Object","assign","objectMode","highWaterMark","_boundary","_generateBoundary","_files","_draining","_flush","push","boundary","i","Math","floor","random","toString","_transform","file","encoding","callback","isBuffer","_maybeDrain","length","shift","_pushFile","err","emit","once","leading","_leading","headers","content","alloc","bind","on","data","drained","pause","resume","keys","forEach","header","leadingStr","join","module","exports"],"sources":["C:/Users/Shreyas/Desktop/DREAMS/DMR-master/DREAMS-system/client/node_modules/ipfs-http-client/src/utils/multipart.js"],"sourcesContent":["'use strict'\n\nconst Transform = require('readable-stream').Transform\nconst isNode = require('detect-node')\n\nconst PADDING = '--'\nconst NEW_LINE = '\\r\\n'\nconst NEW_LINE_BUFFER = Buffer.from(NEW_LINE)\n\nclass Multipart extends Transform {\n  constructor (options) {\n    super(Object.assign({}, options, { objectMode: true, highWaterMark: 1 }))\n\n    this._boundary = this._generateBoundary()\n    this._files = []\n    this._draining = false\n  }\n\n  _flush () {\n    this.push(Buffer.from(PADDING + this._boundary + PADDING + NEW_LINE))\n    this.push(null)\n  }\n\n  _generateBoundary () {\n    var boundary = '--------------------------'\n    for (var i = 0; i < 24; i++) {\n      boundary += Math.floor(Math.random() * 10).toString(16)\n    }\n\n    return boundary\n  }\n\n  _transform (file, encoding, callback) {\n    if (Buffer.isBuffer(file)) {\n      this.push(file)\n      return callback() // early\n    }\n    // not a buffer, must be a file\n    this._files.push(file)\n    this._maybeDrain(callback)\n  }\n\n  _maybeDrain (callback) {\n    if (!this._draining) {\n      if (this._files.length) {\n        this._draining = true\n        const file = this._files.shift()\n        this._pushFile(file, (err) => {\n          this._draining = false\n          if (err) {\n            this.emit('error', err)\n          } else {\n            this._maybeDrain(callback)\n          }\n        })\n      } else {\n        this.emit('drained all files')\n        callback()\n      }\n    } else {\n      this.once('drained all files', callback)\n    }\n  }\n\n  _pushFile (file, callback) {\n    const leading = this._leading(file.headers || {})\n\n    this.push(leading)\n\n    let content = file.content || Buffer.alloc(0)\n\n    if (Buffer.isBuffer(content)) {\n      this.push(content)\n      this.push(NEW_LINE_BUFFER)\n      return callback() // early\n    }\n\n    // From now on we assume content is a stream\n    content.once('error', this.emit.bind(this, 'error'))\n\n    content.once('end', () => {\n      this.push(NEW_LINE_BUFFER)\n      callback()\n\n      // TODO: backpressure!!! wait once self is drained so we can proceed\n      // This does not work\n      // this.once('drain', () => {\n      //   callback()\n      // })\n    })\n\n    content.on('data', (data) => {\n      const drained = this.push(data)\n      // Only do the drain dance on Node.js.\n      // In browserland, the underlying stream\n      // does NOT drain because the request is only sent\n      // once this stream ends.\n      if (!drained && isNode) {\n        content.pause()\n        this.once('drain', () => content.resume())\n      }\n    })\n  }\n\n  _leading (headers) {\n    var leading = [PADDING + this._boundary]\n\n    Object.keys(headers).forEach((header) => {\n      leading.push(header + ': ' + headers[header])\n    })\n\n    leading.push('')\n    leading.push('')\n\n    const leadingStr = leading.join(NEW_LINE)\n\n    return Buffer.from(leadingStr)\n  }\n}\n\nmodule.exports = Multipart\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}