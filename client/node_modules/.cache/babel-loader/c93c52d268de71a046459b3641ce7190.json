{"ast":null,"code":"/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n'use strict';\n\nconst mh = require('multihashes');\n\nconst cryptoKeys = require('libp2p-crypto/src/keys');\n\nconst assert = require('assert');\n\nconst waterfall = require('async/waterfall');\n\nconst withIs = require('class-is');\n\nclass PeerId {\n  constructor(id, privKey, pubKey) {\n    assert(Buffer.isBuffer(id), 'invalid id provided');\n\n    if (privKey && pubKey) {\n      assert(privKey.public.bytes.equals(pubKey.bytes), 'inconsistent arguments');\n    }\n\n    this._id = id;\n    this._idB58String = mh.toB58String(this.id);\n    this._privKey = privKey;\n    this._pubKey = pubKey;\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  set id(val) {\n    throw new Error('Id is immutable');\n  }\n\n  get privKey() {\n    return this._privKey;\n  }\n\n  set privKey(privKey) {\n    this._privKey = privKey;\n  }\n\n  get pubKey() {\n    if (this._pubKey) {\n      return this._pubKey;\n    }\n\n    if (this._privKey) {\n      return this._privKey.public;\n    }\n\n    const decoded = mh.decode(this.id);\n\n    if (decoded.name === 'identity') {\n      this._pubKey = cryptoKeys.unmarshalPublicKey(decoded.digest);\n      return this._pubKey;\n    }\n  }\n\n  set pubKey(pubKey) {\n    this._pubKey = pubKey;\n  } // Return the protobuf version of the public key, matching go ipfs formatting\n\n\n  marshalPubKey() {\n    if (this.pubKey) {\n      return cryptoKeys.marshalPublicKey(this.pubKey);\n    }\n  } // Return the protobuf version of the private key, matching go ipfs formatting\n\n\n  marshalPrivKey() {\n    if (this.privKey) {\n      return cryptoKeys.marshalPrivateKey(this.privKey);\n    }\n  }\n\n  toPrint() {\n    let pid = this.toB58String(); // All sha256 nodes start with Qm\n    // We can skip the Qm to make the peer.ID more useful\n\n    if (pid.startsWith('Qm')) {\n      pid = pid.slice(2);\n    }\n\n    let maxRunes = 6;\n\n    if (pid.length < maxRunes) {\n      maxRunes = pid.length;\n    }\n\n    return '<peer.ID ' + pid.substr(0, maxRunes) + '>';\n  } // return the jsonified version of the key, matching the formatting\n  // of go-ipfs for its config file\n\n\n  toJSON() {\n    return {\n      id: this.toB58String(),\n      privKey: toB64Opt(this.marshalPrivKey()),\n      pubKey: toB64Opt(this.marshalPubKey())\n    };\n  } // encode/decode functions\n\n\n  toHexString() {\n    return mh.toHexString(this.id);\n  }\n\n  toBytes() {\n    return this.id;\n  }\n\n  toB58String() {\n    return this._idB58String;\n  }\n\n  isEqual(id) {\n    if (Buffer.isBuffer(id)) {\n      return this.id.equals(id);\n    } else if (id.id) {\n      return this.id.equals(id.id);\n    } else {\n      throw new Error('not valid Id');\n    }\n  }\n  /*\n   * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n   */\n\n\n  isValid(callback) {\n    // TODO Needs better checking\n    if (this.privKey && this.privKey.public && this.privKey.public.bytes && Buffer.isBuffer(this.pubKey.bytes) && this.privKey.public.bytes.equals(this.pubKey.bytes)) {\n      callback();\n    } else {\n      callback(new Error('Keys not match'));\n    }\n  }\n\n}\n\nconst PeerIdWithIs = withIs(PeerId, {\n  className: 'PeerId',\n  symbolName: '@libp2p/js-peer-id/PeerId'\n});\nexports = module.exports = PeerIdWithIs;\n\nconst computeDigest = (pubKey, cb) => {\n  if (pubKey.bytes.length <= 42) {\n    const digest = mh.encode(pubKey.bytes, 'identity');\n    cb(null, digest);\n  } else {\n    pubKey.hash((err, digest) => {\n      cb(err, digest);\n    });\n  }\n};\n\nconst computePeerId = (privKey, pubKey, cb) => {\n  computeDigest(pubKey, (err, digest) => {\n    if (err != null) {\n      cb(err);\n    } else {\n      cb(null, new PeerIdWithIs(digest, privKey, pubKey));\n    }\n  });\n}; // generation\n\n\nexports.create = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  opts = opts || {};\n  opts.bits = opts.bits || 2048;\n  opts.keyType = opts.keyType || 'RSA';\n  cryptoKeys.generateKeyPair(opts.keyType, opts.bits, (err, privKey) => {\n    if (err != null) {\n      callback(err);\n    } else {\n      computePeerId(privKey, privKey.public, callback);\n    }\n  });\n};\n\nexports.createFromHexString = function (str) {\n  return new PeerIdWithIs(mh.fromHexString(str));\n};\n\nexports.createFromBytes = function (buf) {\n  return new PeerIdWithIs(buf);\n};\n\nexports.createFromB58String = function (str) {\n  return new PeerIdWithIs(mh.fromB58String(str));\n}; // Public Key input will be a buffer\n\n\nexports.createFromPubKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n\n  let pubKey;\n\n  try {\n    let buf = key;\n\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64');\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer');\n    pubKey = cryptoKeys.unmarshalPublicKey(buf);\n  } catch (err) {\n    return callback(err);\n  }\n\n  computePeerId(null, pubKey, callback);\n}; // Private key input will be a string\n\n\nexports.createFromPrivKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n\n  let buf = key;\n\n  try {\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64');\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer');\n  } catch (err) {\n    return callback(err);\n  }\n\n  cryptoKeys.unmarshalPrivateKey(buf, (err, privKey) => {\n    if (err != null) {\n      callback(err);\n    } else {\n      computePeerId(privKey, privKey.public, callback);\n    }\n  });\n};\n\nexports.createFromJSON = function (obj, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n\n  let id;\n  let rawPrivKey;\n  let rawPubKey;\n  let pub;\n\n  try {\n    id = mh.fromB58String(obj.id);\n    rawPrivKey = obj.privKey && Buffer.from(obj.privKey, 'base64');\n    rawPubKey = obj.pubKey && Buffer.from(obj.pubKey, 'base64');\n    pub = rawPubKey && cryptoKeys.unmarshalPublicKey(rawPubKey);\n  } catch (err) {\n    return callback(err);\n  }\n\n  if (!rawPrivKey) {\n    callback(null, new PeerIdWithIs(id, null, pub));\n    return;\n  }\n\n  waterfall([cb => cryptoKeys.unmarshalPrivateKey(rawPrivKey, cb), (priv, cb) => {\n    computeDigest(priv.public, (err, digest) => {\n      cb(err, digest, priv);\n    });\n  }, (privDigest, priv, cb) => {\n    if (pub) {\n      computeDigest(pub, (err, pubDigest) => {\n        cb(err, privDigest, priv, pubDigest);\n      });\n    } else {\n      cb(null, privDigest, priv);\n    }\n  }], (err, privDigest, priv, pubDigest) => {\n    if (err) {\n      return callback(err);\n    }\n\n    if (pub && !privDigest.equals(pubDigest)) {\n      return callback(new Error('Public and private key do not match'));\n    }\n\n    if (id && !privDigest.equals(id)) {\n      return callback(new Error('Id and private key do not match'));\n    }\n\n    callback(null, new PeerIdWithIs(id, priv, pub));\n  });\n};\n\nexports.isPeerId = function (peerId) {\n  return Boolean(typeof peerId === 'object' && peerId._id && peerId._idB58String);\n};\n\nfunction toB64Opt(val) {\n  if (val) {\n    return val.toString('base64');\n  }\n}","map":{"version":3,"names":["mh","require","cryptoKeys","assert","waterfall","withIs","PeerId","constructor","id","privKey","pubKey","Buffer","isBuffer","public","bytes","equals","_id","_idB58String","toB58String","_privKey","_pubKey","val","Error","decoded","decode","name","unmarshalPublicKey","digest","marshalPubKey","marshalPublicKey","marshalPrivKey","marshalPrivateKey","toPrint","pid","startsWith","slice","maxRunes","length","substr","toJSON","toB64Opt","toHexString","toBytes","isEqual","isValid","callback","PeerIdWithIs","className","symbolName","exports","module","computeDigest","cb","encode","hash","err","computePeerId","create","opts","bits","keyType","generateKeyPair","createFromHexString","str","fromHexString","createFromBytes","buf","createFromB58String","fromB58String","createFromPubKey","key","from","createFromPrivKey","unmarshalPrivateKey","createFromJSON","obj","rawPrivKey","rawPubKey","pub","priv","privDigest","pubDigest","isPeerId","peerId","Boolean","toString"],"sources":["C:/Users/Shreyas/Desktop/DMR-master/client/node_modules/peer-id/src/index.js"],"sourcesContent":["/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n\n'use strict'\n\nconst mh = require('multihashes')\nconst cryptoKeys = require('libp2p-crypto/src/keys')\nconst assert = require('assert')\nconst waterfall = require('async/waterfall')\nconst withIs = require('class-is')\n\nclass PeerId {\n  constructor (id, privKey, pubKey) {\n    assert(Buffer.isBuffer(id), 'invalid id provided')\n\n    if (privKey && pubKey) {\n      assert(privKey.public.bytes.equals(pubKey.bytes), 'inconsistent arguments')\n    }\n\n    this._id = id\n    this._idB58String = mh.toB58String(this.id)\n    this._privKey = privKey\n    this._pubKey = pubKey\n  }\n\n  get id () {\n    return this._id\n  }\n\n  set id (val) {\n    throw new Error('Id is immutable')\n  }\n\n  get privKey () {\n    return this._privKey\n  }\n\n  set privKey (privKey) {\n    this._privKey = privKey\n  }\n\n  get pubKey () {\n    if (this._pubKey) {\n      return this._pubKey\n    }\n\n    if (this._privKey) {\n      return this._privKey.public\n    }\n\n    const decoded = mh.decode(this.id)\n\n    if (decoded.name === 'identity') {\n      this._pubKey = cryptoKeys.unmarshalPublicKey(decoded.digest)\n      return this._pubKey\n    }\n  }\n\n  set pubKey (pubKey) {\n    this._pubKey = pubKey\n  }\n\n  // Return the protobuf version of the public key, matching go ipfs formatting\n  marshalPubKey () {\n    if (this.pubKey) {\n      return cryptoKeys.marshalPublicKey(this.pubKey)\n    }\n  }\n\n  // Return the protobuf version of the private key, matching go ipfs formatting\n  marshalPrivKey () {\n    if (this.privKey) {\n      return cryptoKeys.marshalPrivateKey(this.privKey)\n    }\n  }\n\n  toPrint () {\n    let pid = this.toB58String()\n    // All sha256 nodes start with Qm\n    // We can skip the Qm to make the peer.ID more useful\n    if (pid.startsWith('Qm')) {\n      pid = pid.slice(2)\n    }\n    let maxRunes = 6\n    if (pid.length < maxRunes) {\n      maxRunes = pid.length\n    }\n\n    return '<peer.ID ' + pid.substr(0, maxRunes) + '>'\n  }\n\n  // return the jsonified version of the key, matching the formatting\n  // of go-ipfs for its config file\n  toJSON () {\n    return {\n      id: this.toB58String(),\n      privKey: toB64Opt(this.marshalPrivKey()),\n      pubKey: toB64Opt(this.marshalPubKey())\n    }\n  }\n\n  // encode/decode functions\n  toHexString () {\n    return mh.toHexString(this.id)\n  }\n\n  toBytes () {\n    return this.id\n  }\n\n  toB58String () {\n    return this._idB58String\n  }\n\n  isEqual (id) {\n    if (Buffer.isBuffer(id)) {\n      return this.id.equals(id)\n    } else if (id.id) {\n      return this.id.equals(id.id)\n    } else {\n      throw new Error('not valid Id')\n    }\n  }\n\n  /*\n   * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n   */\n  isValid (callback) {\n    // TODO Needs better checking\n    if (this.privKey &&\n      this.privKey.public &&\n      this.privKey.public.bytes &&\n      Buffer.isBuffer(this.pubKey.bytes) &&\n      this.privKey.public.bytes.equals(this.pubKey.bytes)) {\n      callback()\n    } else {\n      callback(new Error('Keys not match'))\n    }\n  }\n}\n\nconst PeerIdWithIs = withIs(PeerId, { className: 'PeerId', symbolName: '@libp2p/js-peer-id/PeerId' })\n\nexports = module.exports = PeerIdWithIs\n\nconst computeDigest = (pubKey, cb) => {\n  if (pubKey.bytes.length <= 42) {\n    const digest = mh.encode(pubKey.bytes, 'identity')\n    cb(null, digest)\n  } else {\n    pubKey.hash((err, digest) => {\n      cb(err, digest)\n    })\n  }\n}\n\nconst computePeerId = (privKey, pubKey, cb) => {\n  computeDigest(pubKey, (err, digest) => {\n    if (err != null) {\n      cb(err)\n    } else {\n      cb(null, new PeerIdWithIs(digest, privKey, pubKey))\n    }\n  })\n}\n\n// generation\nexports.create = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = {}\n  }\n  opts = opts || {}\n  opts.bits = opts.bits || 2048\n  opts.keyType = opts.keyType || 'RSA'\n\n  cryptoKeys.generateKeyPair(opts.keyType, opts.bits, (err, privKey) => {\n    if (err != null) {\n      callback(err)\n    } else {\n      computePeerId(privKey, privKey.public, callback)\n    }\n  })\n}\n\nexports.createFromHexString = function (str) {\n  return new PeerIdWithIs(mh.fromHexString(str))\n}\n\nexports.createFromBytes = function (buf) {\n  return new PeerIdWithIs(buf)\n}\n\nexports.createFromB58String = function (str) {\n  return new PeerIdWithIs(mh.fromB58String(str))\n}\n\n// Public Key input will be a buffer\nexports.createFromPubKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required')\n  }\n\n  let pubKey\n\n  try {\n    let buf = key\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64')\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer')\n\n    pubKey = cryptoKeys.unmarshalPublicKey(buf)\n  } catch (err) {\n    return callback(err)\n  }\n\n  computePeerId(null, pubKey, callback)\n}\n\n// Private key input will be a string\nexports.createFromPrivKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required')\n  }\n\n  let buf = key\n\n  try {\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64')\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer')\n  } catch (err) {\n    return callback(err)\n  }\n\n  cryptoKeys.unmarshalPrivateKey(buf, (err, privKey) => {\n    if (err != null) {\n      callback(err)\n    } else {\n      computePeerId(privKey, privKey.public, callback)\n    }\n  })\n}\n\nexports.createFromJSON = function (obj, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required')\n  }\n\n  let id\n  let rawPrivKey\n  let rawPubKey\n  let pub\n\n  try {\n    id = mh.fromB58String(obj.id)\n    rawPrivKey = obj.privKey && Buffer.from(obj.privKey, 'base64')\n    rawPubKey = obj.pubKey && Buffer.from(obj.pubKey, 'base64')\n    pub = rawPubKey && cryptoKeys.unmarshalPublicKey(rawPubKey)\n  } catch (err) {\n    return callback(err)\n  }\n\n  if (!rawPrivKey) {\n    callback(null, new PeerIdWithIs(id, null, pub))\n    return\n  }\n\n  waterfall([\n    (cb) => cryptoKeys.unmarshalPrivateKey(rawPrivKey, cb),\n    (priv, cb) => {\n      computeDigest(priv.public, (err, digest) => {\n        cb(err, digest, priv)\n      })\n    },\n    (privDigest, priv, cb) => {\n      if (pub) {\n        computeDigest(pub, (err, pubDigest) => {\n          cb(err, privDigest, priv, pubDigest)\n        })\n      } else {\n        cb(null, privDigest, priv)\n      }\n    }\n  ], (err, privDigest, priv, pubDigest) => {\n    if (err) {\n      return callback(err)\n    }\n\n    if (pub && !privDigest.equals(pubDigest)) {\n      return callback(new Error('Public and private key do not match'))\n    }\n\n    if (id && !privDigest.equals(id)) {\n      return callback(new Error('Id and private key do not match'))\n    }\n\n    callback(null, new PeerIdWithIs(id, priv, pub))\n  })\n}\n\nexports.isPeerId = function (peerId) {\n  return Boolean(typeof peerId === 'object' &&\n    peerId._id &&\n    peerId._idB58String)\n}\n\nfunction toB64Opt (val) {\n  if (val) {\n    return val.toString('base64')\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}